#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <limits>
#include <algorithm>

// Forward declarations
class Entity;
class Supplier;
class Product;
class Order;
class OrderItem;

// Abstract base class
class Entity {
protected:
    int id;
    static int nextId;

public:
    Entity() : id(nextId++) {}
    Entity(int forcedId) : id(forcedId) {}  // New constructor for loading
    virtual ~Entity() = default;
    
    int getId() const { return id; }
    virtual void displayInfo() const = 0;
    virtual std::string toFileString() const = 0;
    
    // Static method to update nextId when loading
    static void updateNextId(int loadedId) {
        if (loadedId >= nextId) {
            nextId = loadedId + 1;
        }
    }

    static int getCurrentNextId() { return nextId; }  // For debugging
};

int Entity::nextId = 1;

// Supplier class
class Supplier : public Entity {
private:
    std::string name;
    std::string contactPerson;
    std::string phone;
    std::string email;
    std::string address;
    double performanceRating;

public:
    Supplier(const std::string& name = "", const std::string& contactPerson = "",
             const std::string& phone = "", const std::string& email = "",
             const std::string& address = "", double rating = 0.0)
        : name(name), contactPerson(contactPerson), phone(phone),
          email(email), address(address), performanceRating(rating) {}

    // Getters
    std::string getName() const { return name; }
    std::string getContactPerson() const { return contactPerson; }
    std::string getPhone() const { return phone; }
    std::string getEmail() const { return email; }
    std::string getAddress() const { return address; }
    double getPerformanceRating() const { return performanceRating; }

    // Setters
    void setPerformanceRating(double rating) { performanceRating = rating; }
    void setName(const std::string& newName) { name = newName; }
    void setContactPerson(const std::string& person) { contactPerson = person; }
    void setPhone(const std::string& newPhone) { phone = newPhone; }
    void setEmail(const std::string& newEmail) { email = newEmail; }
    void setAddress(const std::string& newAddress) { address = newAddress; }

    void displayInfo() const override {
        std::cout << "Supplier ID: " << id << "\n"
                  << "Name: " << name << "\n"
                  << "Contact Person: " << contactPerson << "\n"
                  << "Phone: " << phone << "\n"
                  << "Email: " << email << "\n"
                  << "Address: " << address << "\n"
                  << "Performance Rating: " << performanceRating << "\n"
                  << "------------------------\n";
    }

    std::string toFileString() const override {
        std::ostringstream oss;
        oss << "SUPPLIER|" << id << "|" << name << "|" << contactPerson << "|"
            << phone << "|" << email << "|" << address << "|" << performanceRating;
        return oss.str();
    }

    static Supplier fromFileString(const std::string& data) {
        std::istringstream iss(data);
        std::string token;
        std::vector<std::string> tokens;
        
        while (std::getline(iss, token, '|')) {
            tokens.push_back(token);
        }
        
        if (tokens.size() >= 8 && tokens[0] == "SUPPLIER") {
            int loadedId = std::stoi(tokens[1]);
            Entity::updateNextId(loadedId);  // Update the ID counter
            
            Supplier supplier;
            supplier.id = loadedId;  // Use the loaded ID
            supplier.name = tokens[2];
            supplier.contactPerson = tokens[3];
            supplier.phone = tokens[4];
            supplier.email = tokens[5];
            supplier.address = tokens[6];
            supplier.performanceRating = std::stod(tokens[7]);
            return supplier;
        }
        throw std::invalid_argument("Invalid supplier data format");
    }
};

// Product class
class Product : public Entity {
private:
    std::string name;
    std::string category;
    double price;

public:
    Product(const std::string& name = "", const std::string& category = "", double price = 0.0)
        : name(name), category(category), price(price) {}

    // Getters
    std::string getName() const { return name; }
    std::string getCategory() const { return category; }
    double getPrice() const { return price; }

    // Setters
    void setName(const std::string& newName) { name = newName; }
    void setCategory(const std::string& newCategory) { category = newCategory; }
    void setPrice(double newPrice) { price = newPrice; }

    void displayInfo() const override {
        std::cout << "Product ID: " << id << "\n"
                  << "Name: " << name << "\n"
                  << "Category: " << category << "\n"
                  << "Price: $" << std::fixed << std::setprecision(2) << price << "\n"
                  << "------------------------\n";
    }

    std::string toFileString() const override {
        std::ostringstream oss;
        oss << "PRODUCT|" << id << "|" << name << "|" << category << "|" << price;
        return oss.str();
    }

    static Product fromFileString(const std::string& data) {
        std::istringstream iss(data);
        std::string token;
        std::vector<std::string> tokens;
        
        while (std::getline(iss, token, '|')) {
            tokens.push_back(token);
        }
        
        if (tokens.size() >= 5 && tokens[0] == "PRODUCT") {
            int loadedId = std::stoi(tokens[1]);
            Entity::updateNextId(loadedId);  // Update the ID counter
            
            Product product;
            product.id = loadedId;  // Use the loaded ID
            product.name = tokens[2];
            product.category = tokens[3];
            product.price = std::stod(tokens[4]);
            return product;
        }
        throw std::invalid_argument("Invalid product data format");
    }
};

// Order Item class
class OrderItem {
private:
    int productId;
    std::string productName;
    int quantity;
    double unitPrice;

public:
    OrderItem(int productId = 0, const std::string& productName = "", 
              int quantity = 0, double unitPrice = 0.0)
        : productId(productId), productName(productName), 
          quantity(quantity), unitPrice(unitPrice) {}

    int getProductId() const { return productId; }
    std::string getProductName() const { return productName; }
    int getQuantity() const { return quantity; }
    double getUnitPrice() const { return unitPrice; }
    double getTotalPrice() const { return quantity * unitPrice; }

    void setQuantity(int qty) { quantity = qty; }

    std::string toFileString() const {
        std::ostringstream oss;
        oss << productId << "|" << productName << "|" << quantity << "|" << unitPrice;
        return oss.str();
    }

    static OrderItem fromFileString(const std::string& data) {
        std::istringstream iss(data);
        std::string token;
        std::vector<std::string> tokens;
        
        while (std::getline(iss, token, '|')) {
            tokens.push_back(token);
        }
        
        if (tokens.size() >= 4) {
            return OrderItem(std::stoi(tokens[0]), tokens[1], 
                           std::stoi(tokens[2]), std::stod(tokens[3]));
        }
        throw std::invalid_argument("Invalid order item data format");
    }
};

// Order class
class Order : public Entity {
private:
    int supplierId;
    std::string supplierName;
    std::vector<OrderItem> items;
    std::string status;
    double totalPrice;

public:
    Order(int supplierId = 0, const std::string& supplierName = "")
        : supplierId(supplierId), supplierName(supplierName), status("Pending"), totalPrice(0.0) {}

    // Getters
    int getSupplierId() const { return supplierId; }
    std::string getSupplierName() const { return supplierName; }
    std::string getStatus() const { return status; }
    double getTotalPrice() const { return totalPrice; }
    const std::vector<OrderItem>& getItems() const { return items; }

    // Setters
    void setStatus(const std::string& newStatus) { status = newStatus; }
    void setSupplierId(int id) { supplierId = id; }
    void setSupplierName(const std::string& name) { supplierName = name; }

    void addItem(const OrderItem& item) {
        items.push_back(item);
        calculateTotalPrice();
    }

    void removeItem(int index) {
        if (index >= 0 && index < items.size()) {
            items.erase(items.begin() + index);
            calculateTotalPrice();
        }
    }

    void calculateTotalPrice() {
        totalPrice = 0.0;
        for (const auto& item : items) {
            totalPrice += item.getTotalPrice();
        }
    }

    void displayInfo() const override {
        std::cout << "Order ID: " << id << "\n"
                  << "Supplier ID: " << supplierId << "\n"
                  << "Supplier Name: " << supplierName << "\n"
                  << "Status: " << status << "\n"
                  << "Total Price: $" << std::fixed << std::setprecision(2) << totalPrice << "\n"
                  << "Items:\n";
        
        for (size_t i = 0; i < items.size(); ++i) {
            std::cout << "  " << (i + 1) << ". " << items[i].getProductName()
                      << " (Qty: " << items[i].getQuantity()
                      << ", Price: $" << items[i].getUnitPrice()
                      << ", Total: $" << items[i].getTotalPrice() << ")\n";
        }
        std::cout << "------------------------\n";
    }

    std::string toFileString() const override {
        std::ostringstream oss;
        oss << "ORDER|" << id << "|" << supplierId << "|" << supplierName << "|"
            << status << "|" << totalPrice << "|" << items.size();
        
        for (const auto& item : items) {
            oss << "|" << item.toFileString();
        }
        
        return oss.str();
    }

    static Order fromFileString(const std::string& data) {
        std::istringstream iss(data);
        std::string token;
        std::vector<std::string> tokens;
        
        while (std::getline(iss, token, '|')) {
            tokens.push_back(token);
        }
        
        if (tokens.size() >= 7 && tokens[0] == "ORDER") {
            int loadedId = std::stoi(tokens[1]);
            Entity::updateNextId(loadedId);  // Update the ID counter
            
            Order order;
            order.id = loadedId;  // Use the loaded ID
            order.supplierId = std::stoi(tokens[2]);
            order.supplierName = tokens[3];
            order.status = tokens[4];
            order.totalPrice = std::stod(tokens[5]);
            int itemCount = std::stoi(tokens[6]);
            
            // Read order items
            for (int i = 0; i < itemCount && (7 + i) < tokens.size(); ++i) {
                order.items.push_back(OrderItem::fromFileString(tokens[7 + i]));
            }
            
            return order;
        }
        throw std::invalid_argument("Invalid order data format");
    }
};

// Data Manager class
class DataManager {
private:
    std::vector<Supplier> suppliers;
    std::vector<Product> products;
    std::vector<Order> orders;

public:
    // Supplier management
    void addSupplier(const Supplier& supplier) {
        suppliers.push_back(supplier);
    }

    void listSuppliers() const {
        if (suppliers.empty()) {
            std::cout << "No suppliers found.\n";
            return;
        }
        std::cout << "=== SUPPLIERS ===\n";
        for (const auto& supplier : suppliers) {
            supplier.displayInfo();
        }
    }

    Supplier* findSupplierById(int id) {
        for (auto& supplier : suppliers) {
            if (supplier.getId() == id) {
                return &supplier;
            }
        }
        return nullptr;
    }

    bool removeSupplier(int id) {
        auto it = std::remove_if(suppliers.begin(), suppliers.end(),
                               [id](const Supplier& s) { return s.getId() == id; });
        if (it != suppliers.end()) {
            suppliers.erase(it, suppliers.end());
            return true;
        }
        return false;
    }

    // Product management
    void addProduct(const Product& product) {
        products.push_back(product);
    }

    void listProducts() const {
        if (products.empty()) {
            std::cout << "No products found.\n";
            return;
        }
        std::cout << "=== PRODUCTS ===\n";
        for (const auto& product : products) {
            product.displayInfo();
        }
    }

    Product* findProductById(int id) {
        for (auto& product : products) {
            if (product.getId() == id) {
                return &product;
            }
        }
        return nullptr;
    }

    // Order management
    void addOrder(const Order& order) {
        orders.push_back(order);
    }

    void listOrders() const {
        if (orders.empty()) {
            std::cout << "No orders found.\n";
            return;
        }
        std::cout << "=== ORDERS ===\n";
        for (const auto& order : orders) {
            order.displayInfo();
        }
    }

    Order* findOrderById(int id) {
        for (auto& order : orders) {
            if (order.getId() == id) {
                return &order;
            }
        }
        return nullptr;
    }

    // File operations
    void saveToFile(const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Cannot open file for writing: " + filename);
        }

        // Save suppliers
        for (const auto& supplier : suppliers) {
            file << supplier.toFileString() << "\n";
        }

        // Save products
        for (const auto& product : products) {
            file << product.toFileString() << "\n";
        }

        // Save orders
        for (const auto& order : orders) {
            file << order.toFileString() << "\n";
        }

        file.close();
        std::cout << "Data saved successfully to " << filename << "\n";
    }

    void loadFromFile(const std::string& filename) {
        std::ifstream file(filename);
        if (!file.is_open()) {
            std::cout << "No existing data file found. Starting with empty database.\n";
            return;
        }

        suppliers.clear();
        products.clear();
        orders.clear();

        std::string line;
        int loadedCount = 0;
        
        while (std::getline(file, line)) {
            if (line.empty()) continue;

            try {
                if (line.find("SUPPLIER|") == 0) {
                    suppliers.push_back(Supplier::fromFileString(line));
                    loadedCount++;
                } else if (line.find("PRODUCT|") == 0) {
                    products.push_back(Product::fromFileString(line));
                    loadedCount++;
                } else if (line.find("ORDER|") == 0) {
                    orders.push_back(Order::fromFileString(line));
                    loadedCount++;
                }
            } catch (const std::exception& e) {
                std::cerr << "Error loading data: " << e.what() << "\n";
            }
        }

        file.close();
        std::cout << "Data loaded successfully from " << filename 
                  << " (" << loadedCount << " records)\n";
        
        // Debug: Show what was loaded
        std::cout << "Loaded: " << suppliers.size() << " suppliers, "
                  << products.size() << " products, "
                  << orders.size() << " orders\n";
    }

    // Getters for collections
    const std::vector<Supplier>& getSuppliers() const { return suppliers; }
    const std::vector<Product>& getProducts() const { return products; }
    const std::vector<Order>& getOrders() const { return orders; }
};

// Utility functions
void clearInputBuffer() {
    std::cin.clear();
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

int getValidatedInt(const std::string& prompt) {
    int value;
    while (true) {
        std::cout << prompt;
        if (std::cin >> value) {
            clearInputBuffer();
            return value;
        } else {
            std::cout << "Invalid input. Please enter a valid number.\n";
            clearInputBuffer();
        }
    }
}

double getValidatedDouble(const std::string& prompt) {
    double value;
    while (true) {
        std::cout << prompt;
        if (std::cin >> value) {
            clearInputBuffer();
            return value;
        } else {
            std::cout << "Invalid input. Please enter a valid number.\n";
            clearInputBuffer();
        }
    }
}

std::string getValidatedString(const std::string& prompt) {
    std::string value;
    std::cout << prompt;
    std::getline(std::cin, value);
    return value;
}

// Menu system
class MenuSystem {
private:
    DataManager dataManager;
    const std::string dataFile = "supplier_data.txt";

public:
    MenuSystem() {
        std::cout << "Loading data...\n";
        dataManager.loadFromFile(dataFile);
    }

    ~MenuSystem() {
        std::cout << "Saving data...\n";
        dataManager.saveToFile(dataFile);
    }

    void showMainMenu() {
        while (true) {
            std::cout << "\n=== Supplier Management System ===\n"
                      << "1. Supplier Management\n"
                      << "2. Product Management\n"
                      << "3. Order Management\n"
                      << "4. Save Data\n"
                      << "5. Exit\n"
                      << "Choose an option: ";

            int choice = getValidatedInt("");
            
            switch (choice) {
                case 1: showSupplierMenu(); break;
                case 2: showProductMenu(); break;
                case 3: showOrderMenu(); break;
                case 4: 
                    dataManager.saveToFile(dataFile);
                    break;
                case 5: 
                    std::cout << "Goodbye!\n";
                    return;
                default:
                    std::cout << "Invalid option. Please try again.\n";
            }
        }
    }

private:
    void showSupplierMenu() {
        while (true) {
            std::cout << "\n=== Supplier Management ===\n"
                      << "1. Add Supplier\n"
                      << "2. List Suppliers\n"
                      << "3. Update Supplier Rating\n"
                      << "4. Remove Supplier\n"
                      << "5. Back to Main Menu\n"
                      << "Choose an option: ";

            int choice = getValidatedInt("");
            
            switch (choice) {
                case 1: addSupplier(); break;
                case 2: dataManager.listSuppliers(); break;
                case 3: updateSupplierRating(); break;
                case 4: removeSupplier(); break;
                case 5: return;
                default:
                    std::cout << "Invalid option. Please try again.\n";
            }
        }
    }

    void showProductMenu() {
        while (true) {
            std::cout << "\n=== Product Management ===\n"
                      << "1. Add Product\n"
                      << "2. List Products\n"
                      << "3. Back to Main Menu\n"
                      << "Choose an option: ";

            int choice = getValidatedInt("");
            
            switch (choice) {
                case 1: addProduct(); break;
                case 2: dataManager.listProducts(); break;
                case 3: return;
                default:
                    std::cout << "Invalid option. Please try again.\n";
            }
        }
    }

    void showOrderMenu() {
        while (true) {
            std::cout << "\n=== Order Management ===\n"
                      << "1. Create Order\n"
                      << "2. List Orders\n"
                      << "3. Update Order Status\n"
                      << "4. Back to Main Menu\n"
                      << "Choose an option: ";

            int choice = getValidatedInt("");
            
            switch (choice) {
                case 1: createOrder(); break;
                case 2: dataManager.listOrders(); break;
                case 3: updateOrderStatus(); break;
                case 4: return;
                default:
                    std::cout << "Invalid option. Please try again.\n";
            }
        }
    }

    void addSupplier() {
        std::string name = getValidatedString("Enter supplier name: ");
        std::string contactPerson = getValidatedString("Enter contact person: ");
        std::string phone = getValidatedString("Enter phone: ");
        std::string email = getValidatedString("Enter email: ");
        std::string address = getValidatedString("Enter address: ");
        double rating = getValidatedDouble("Enter performance rating: ");

        Supplier supplier(name, contactPerson, phone, email, address, rating);
        dataManager.addSupplier(supplier);
        std::cout << "Supplier added successfully! ID: " << supplier.getId() << "\n";
    }

    void addProduct() {
        std::string name = getValidatedString("Enter product name: ");
        std::string category = getValidatedString("Enter category: ");
        double price = getValidatedDouble("Enter price: ");

        Product product(name, category, price);
        dataManager.addProduct(product);
        std::cout << "Product added successfully! ID: " << product.getId() << "\n";
    }

    void updateSupplierRating() {
        int id = getValidatedInt("Enter supplier ID: ");
        Supplier* supplier = dataManager.findSupplierById(id);
        
        if (supplier) {
            double newRating = getValidatedDouble("Enter new performance rating: ");
            supplier->setPerformanceRating(newRating);
            std::cout << "Supplier rating updated successfully!\n";
        } else {
            std::cout << "Supplier not found!\n";
        }
    }

    void removeSupplier() {
        int id = getValidatedInt("Enter supplier ID to remove: ");
        
        if (dataManager.removeSupplier(id)) {
            std::cout << "Supplier removed successfully!\n";
        } else {
            std::cout << "Supplier not found!\n";
        }
    }

    void createOrder() {
        dataManager.listSuppliers();
        if (dataManager.getSuppliers().empty()) {
            std::cout << "No suppliers available. Please add a supplier first.\n";
            return;
        }
        
        int supplierId = getValidatedInt("Enter supplier ID: ");
        Supplier* supplier = dataManager.findSupplierById(supplierId);
        
        if (!supplier) {
            std::cout << "Supplier not found!\n";
            return;
        }

        Order order(supplier->getId(), supplier->getName());
        
        while (true) {
            std::cout << "\nCurrent order items:\n";
            const auto& items = order.getItems();
            if (items.empty()) {
                std::cout << "  No items yet\n";
            } else {
                for (size_t i = 0; i < items.size(); ++i) {
                    std::cout << "  " << (i + 1) << ". " << items[i].getProductName()
                              << " (Qty: " << items[i].getQuantity() << ")\n";
                }
            }
            
            std::cout << "\n1. Add Product to Order\n"
                      << "2. Finish Order\n"
                      << "Choose an option: ";
            
            int choice = getValidatedInt("");
            
            if (choice == 1) {
                dataManager.listProducts();
                if (dataManager.getProducts().empty()) {
                    std::cout << "No products available. Please add a product first.\n";
                    continue;
                }
                
                int productId = getValidatedInt("Enter product ID: ");
                Product* product = dataManager.findProductById(productId);
                
                if (product) {
                    int quantity = getValidatedInt("Enter quantity: ");
                    OrderItem item(product->getId(), product->getName(), quantity, product->getPrice());
                    order.addItem(item);
                    std::cout << "Product added to order!\n";
                } else {
                    std::cout << "Product not found!\n";
                }
            } else if (choice == 2) {
                if (order.getItems().empty()) {
                    std::cout << "Order must have at least one item. Cannot finish empty order.\n";
                    continue;
                }
                break;
            } else {
                std::cout << "Invalid option!\n";
            }
        }
        
        dataManager.addOrder(order);
        std::cout << "Order created successfully! Order ID: " << order.getId() << "\n";
    }

    void updateOrderStatus() {
        dataManager.listOrders();
        if (dataManager.getOrders().empty()) {
            std::cout << "No orders available.\n";
            return;
        }
        
        int orderId = getValidatedInt("Enter order ID: ");
        Order* order = dataManager.findOrderById(orderId);
        
        if (order) {
            std::cout << "Current status: " << order->getStatus() << "\n";
            std::cout << "1. Pending\n2. Delivered\n3. Cancelled\n";
            int statusChoice = getValidatedInt("Choose new status: ");
            
            switch (statusChoice) {
                case 1: order->setStatus("Pending"); break;
                case 2: order->setStatus("Delivered"); break;
                case 3: order->setStatus("Cancelled"); break;
                default:
                    std::cout << "Invalid status choice!\n";
                    return;
            }
            std::cout << "Order status updated successfully!\n";
        } else {
            std::cout << "Order not found!\n";
        }
    }
};

int main() {
    try {
        MenuSystem menuSystem;
        menuSystem.showMainMenu();
    } catch (const std::exception& e) {
        std::cerr << "Fatal error: " << e.what() << "\n";
        return 1;
    }
    
    return 0;
}
